在开始先给大家列出几个术语，不做解释，不懂的可以参考其它资料。

```
术语和符号：
退出状态码
$?
[...] (中括号,方括号)
[[...]] (双中括号，双方括号)
((...)) (双括号)
(...) (单括号)
```

if语句是一种条件判断语句。

首先，标准的if语句的语法是不含中括号的。

其语法如下：

```
if condition; then
    echo yes
else
    echo no
fi
```

即 condition 的代码执行后，退出状态码为真即执行 then 后的语句，

否则，执行else后的语句。

但是需要注意一点的是，这里的真值是0,即返回状态吗为0即为真值,和其他语言0表示逻辑假不同。

那么如何查看单条语句的返回状态码？

使用下面的命令：

```
echo $?
```

返回状态码保存在 $? 环境变量中，每执行过一个命令后都会被更新

test 是一个 shell 内建命令
根据 test 的 man 帮助，可知 test 的功能是检查文件类型和比较值。

先来看一条简单的 test 语句。

```
test 5 -eq 5; echo $? # 输出0
test 5 -eq 4; echo $? # 输出1
```

其中的-eq是运算符。

```bash
test 支持的运算符有下面这些
# 表达式运算符
expression  # 表达式为真(任何命令)
!   # 表达式为假
-a  # 逻辑与 表达式1 –a 表达式2 两个表达式都为真
-o  # 逻辑或 表达式1 –o 表达式2 两个表达式有一个为真
# 字符串运算符
-n    # 字符串的长度为非零
-z    # 字符串的长度为零
=     # 字符串相等
!=    # 字符串不等
# 整数比较运算符
-eq   # int1 -eq int2 如果 int1 等于 int2，则为真
-ge   # int1 -ge int2 如果 int1 大于或等于 int2，则为真
-gt   # int1 -gt int2 如果 int1 大于 int2，则为真
-le   # int1 -le int2 如果 int1 小于或等于 int2，则为真
-lt   # int1 -lt int2 如果 int1 小于 int2，则为真
-ne   # int1 -ne int2 如果 int1 不等于 int2，则为真
# 文件运算符
-ef   # File1 –ef File2 两个文件具有同样的设备号和i结点号
-nt   # File1 –nt File2 文件1比文件2新
-ot   # File1 –ot File2 文件1比文件2旧
–b    # 文件存在并且是块设备文件
–c    # 文件存在并且是字符设备文件
–d    # 文件存在并且是目录
–e    # 文件存在
–f    # 文件存在并且是正规文件
–g    # 文件存在并且是设置了组ID
–G    # 文件存在并且属于有效组ID
–h    # 文件存在并且是一个符号链接（同-L）
–k    # 文件存在并且设置了sticky位
–b    # 文件存在并且是块设备文件
–L    # 文件存在并且是一个符号链接（同-h）
–o    # 文件存在并且属于有效用户ID
–p    # 文件存在并且是一个命名管道
–r    # 文件存在并且可读
–s    # 文件存在并且是一个套接字
–t    # FD 文件描述符是在一个终端打开的
–u    # 文件存在并且设置了它的set-user-id位
–w    # 文件存在并且可写
–x    # 文件存在并且可执行
```

*方括号
方括号是shell的内建符号，2个方括号扩起来的内容与调用test命令判断的结果是一样的。
需要注意的是，方括号内部紧邻括号2边必须有空格。
所以下面的2个test语句可以改成用方括号来表达。

```bash
test 5 -eq 5; echo $? # 输出0
test 5 -eq 4; echo $? # 输出1

[ 5 -eq 5 ]; echo $? # 输出0
[ 5 -eq 4 ]; echo $? # 输出1
```

*双方括号
双方括号是shell的关键字。
需要注意的是，双方括号内部紧邻括号2边必须有空格。
双方括号的主要功能是可以满足其内表达式的转义需求，就是说可以像在其他语言中一样使用出现的比较符号。
比如 <,>,==,!= 等，而这些符号在单方括号中只能用做字符串的比较。
比如 &&,|| ，在单方括号中是不能使用的。

*双括号
双括号用来支持算术表达式。
需要注意的是只支持整数型计算，不支持浮点数。
下面将双括号的几个用法举例说明

```
# 1 整数扩展，输出 true
if (( 2 * 3 == 6 )); then
    echo true
fi

# 2 三目运算符支持， 输出 true
if (( 2 * 3 == 6 ? 1 : 0 )); then
    echo true
fi

# 3 变量赋值,输出 6
a=5; ((a++))
echo $a

# 4 for 循环
for (( i = 0; i < 5; i++)); do
    echo $i;
done
```

*单括号
1 启动一个 subshell 来执行括号内的代码，subshell 有独立的环境变量

```
# 比如下面的脚本
~$ cd /tmp/; sleep 5; cd ~
^C
/tmp$
# cd ~是没有执行的，如果你想实现上面的逻辑，使用下面的小括号脚本即可
~$ ( cd /tmp/; sleep 5; ) cd ~
^C
~$
```



```bash

2 变量或者命令替换
常见 $(variable)

3 初始化数组
array=(a b c d)


接下来是一个demo，内含详细注释
#!/bin/bash

# 单方括号内可以使用变量
SWAP_DEVICE=/dev/sda1
if [ ${SWAP_DEVICE} == "/dev/sda1" ]; then
    echo "单方括号内可以使用变量"
fi

# 双方括号内可以使用变量
SWAP_DEVICE=/dev/sda1
if [[ ${SWAP_DEVICE} == "/dev/sda1" ]]; then
    echo "双方括号内可以使用变量"
fi

# 此处4被当作字符串进行比较
if [ 4 == 4 ]; then
    echo "[ 4 == 4 ] (true)"
fi

echo -e "\n***单方括号支持 test 命令的所有运算符，还支持以下的关系运算符 >,<,=,==,!="
echo -e "***这些关系运算符只限于字符串使用"
echo -e "***除此之外其他的符号都不支持"
echo -e "\n"

# 此处的数字同样被当作字符串处理，所以条件返回真
# 字符串的比较总是从头开始比较第一个不相同的字符
if [[ 44 > 211 ]]; then
    echo "[[ 44 > 211 ]] (true)"
fi

# 此处的数字同样被当作字符串处理，所以条件返回假
if [[ 4 == 2*2 ]]; then
    echo "[[ 4 == 2*2 ]] (true)"
else
    echo "[[ 4 == 2*2 ]] (false)"
    echo "等同于 [ 4 == 2*2 ] (false)"
    echo "[[ 4 == 2 * 2 ]] (error)"
fi

# && 符号不是单方括号支持的符号，但是是双方括号支持的符号
if [[ abc = abc && def = def ]]; then
    echo "[[ abc = abc && def = def ]]"
    echo "[ abc = abc && def = def ] (error)"
fi

echo -e "\n***双方括号只比单方括号多支持了2个符号 && 和 ||\n"

if (( 2 * 3 == 6 )); then
    echo "(( 2 * 3 == 6 )) (true)"
fi

if (( 2 * 3 == 6 ? 1 : 0 )); then
    echo "(( 2 * 3 == 6 ? 1 : 0 ))"
    echo "双括号支持三目运算符"
fi

# 双括号在变量赋值中的使用
a=5; ((a++))
echo "++操作  $a"

# 双括号在 for 循环中的使用
for (( i = 0; i < 5; i++)); do
    echo "循环中${i}";
done

# 如何判断空的变量？
# 这里会出现一个误区 [ ${emptyvar} = "" ],这个等于 [  = "" ],所以会报错
# 而下面的2个方法都是可行的
emptyvar=
if [ "${emptyvar}" = "" ]; then
    echo "empty var"
fi
if [ -z ${emptyvar} ]; then
    echo "empty var"
fi
```

